/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package procmusic;

import java.util.logging.Level;
import java.util.logging.Logger;
import org.jfugue.Player;
import java.lang.Math;

/**
 *
 * @author Eric Dobbs
 */


public class ProcMusic extends javax.swing.JFrame {

    /**
     * Creates new form ProcMusicUI
     */
    public ProcMusic() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jSlider1 = new javax.swing.JSlider();
        jPanel3 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jSlider3 = new javax.swing.JSlider();
        jPanel4 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jSlider5 = new javax.swing.JSlider();
        jPanel5 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jCheckBox1 = new javax.swing.JCheckBox();
        jCheckBox2 = new javax.swing.JCheckBox();
        jPanel6 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jPanel7 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jSlider4 = new javax.swing.JSlider();
        jPanel9 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jSlider7 = new javax.swing.JSlider();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Tempo");

        jSlider1.setMaximum(300);
        jSlider1.setMinimum(30);
        jSlider1.setValue(120);
        jSlider1.setName("Tempo"); // NOI18N

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jSlider1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel1)
            .addComponent(jSlider1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        jLabel2.setText("Granularity");
        jLabel2.setToolTipText("Controls the number of notes in each measure");

        jSlider3.setMaximum(6);
        jSlider3.setMinimum(1);
        jSlider3.setToolTipText("");
        jSlider3.setValue(4);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jSlider3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jSlider3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jLabel5.setText("Syncopation");

        jSlider5.setValue(40);

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 23, Short.MAX_VALUE)
                .addComponent(jSlider5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel5)
            .addComponent(jSlider5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        jButton1.setText("Play");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jCheckBox1.setLabel("Loop");

        jCheckBox2.setText("Procedural rhythms");

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBox1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBox2)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(jButton1)
                .addComponent(jCheckBox1)
                .addComponent(jCheckBox2))
        );

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jTextArea1.setRows(5);
        jTextArea1.setToolTipText("Display window for generated rhythms");
        jScrollPane1.setViewportView(jTextArea1);

        jTextArea2.setColumns(3);
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1)
                .addContainerGap())
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
        );

        jLabel6.setText("Density");

        jSlider4.setValue(70);

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 56, Short.MAX_VALUE)
                .addComponent(jSlider4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel6)
                    .addComponent(jSlider4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jLabel8.setText("Eccentricity");

        jSlider7.setValue(20);

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 37, Short.MAX_VALUE)
                .addComponent(jSlider7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel8)
                    .addComponent(jSlider7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel4, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel9, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(0, 0, 0))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel9, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:

        Player myPlayer = new Player();
        jTextArea1.setText("");
        jTextArea2.setText("");
        playThread mt = new playThread(getPhrase());
        Thread newThread = new Thread(mt);
        newThread.start();
    }//GEN-LAST:event_jButton1ActionPerformed

    
    class playThread implements Runnable {
        // playThread first creates a timerThread, then generates a phrase
        // of music and plays it. timerThread should finish at the same time
        // as playThread
        String song;
        playThread( String str) {
            song = "T" + jSlider1.getValue() + " " + str;
        }
        @Override
        public void run() {
            timerThread tt = new timerThread(0);
            Thread newThread = new Thread(tt);
            newThread.start();
            Player threadPlayer = new Player();
            System.out.println("Playing song: " + song);
            threadPlayer.play(song);
        }
    }
    
    class timerThread implements Runnable {
        // timerThread sits around and waits for a preset amount of time, 
        // then creates a new playThread. Ideally, timerThread should finish
        // at the same time as the previous playThread, creating a constant
        // stream of music. This has yet to be nailed down
        int timer;
        timerThread(int i) {
            timer = i;
        }
        @Override
        public void run() {
            try {
                Thread.sleep((int)(60000.0/jSlider1.getValue() * 16));
            } catch (InterruptedException ex) {
                Logger.getLogger(ProcMusic.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (jCheckBox1.isSelected()) {
                jTextArea1.setText("");
                jTextArea2.setText("");
                playThread mt = new playThread(getPhrase());
                Thread newThread = new Thread(mt);
                newThread.start();
            }
        }
    }
    
    int[] getScale(String chord) {
        // Given a string representing a chord ("C", "Em", "F#"), getScale
        // returns the set of 8 notes making up the framework that can
        // used for creating a melody within that chord
        
        int rt = 60; // Root is middle-C, which is note 60
        String chordNat = String.valueOf(chord.charAt(0));
        String notes = "C D EF G A B";
        String chordCircle = "FCGDAEB";     // Order of keys for sharps/flats
        rt += notes.indexOf( chordNat );
        if (chord.contains("b")) 
            rt -= 1; // Flat keys are one half-step lower
        else if (chord.contains("#"))
            rt += 1; // Sharp keys are one half-step higher
        int scale[] = {rt, rt+2, rt+4, rt+5, rt+7, rt+9, rt+11, rt+12};
        // Initialize the scale based on a standard major scale
        if (chord.contains("m")) 
            scale[2] = scale[2]-1;
            //Minor key? Lower the 3rd by 1/2 step
        if (chordCircle.indexOf(chordNat)<1 | chord.contains("b"))
            scale[3] = scale[3]+1;
            //Flat key? For some reason that means raise the 4th by 1/2
        if (chordCircle.indexOf(chordNat)>1 & !chord.contains("b"))
            scale[6] = scale[6]-1;
            //Sharp key? Lower the 7th by 1/2
        if (chordCircle.indexOf(chordNat)>3 & !chord.contains("b"))
            scale[5] = scale[5]-1;
            //Really sharp key? Lower the 6th by 1/2
        return scale;
    }
    
    String getPhrase() {
        // getPhrase creates a phrase of music based on a randomly
        // chosen chord progression
        int randNum;
        int root = 60;
        int base;
        String song = "";
        String progression[][] = {
            {"C","F","G","C"},
            {"C","F","C","G"},
            {"C","D","F","G"},
            {"C","Am","F","G"},
            {"C","G","Am","F"},
            {"C","Bb","F","G"},
            {"C","Bb","Ab","G"},
            {"C","Bb","Ab","Bb"},
            {"C","Bb","C","Bb"}
        };
        randNum = randNum(0,progression.length - 1);
        for(int i=0; i<progression[randNum].length; i++) {
            jTextArea2.setText(jTextArea2.getText() + progression[randNum][i] + "\n");
            if (jCheckBox2.isSelected()) 
                song += randMeasure(getScale(progression[randNum][i]));
            else
                song += randMeasurePreGen(getScale(progression[randNum][i]));
            
        }
        return song;
    }
    /*
    int[] doubleFineness(int[] arrayIn) {
        int[] arrayOut = new int[arrayIn.length * 2];
        for (int ii=0; ii<arrayIn.length; ii++) {
            arrayOut[ii*2] = arrayIn[ii];
            arrayOut[ii*2 + 1] = -1;
        }
        return arrayOut;
    }
        
    String randRhythm(int minNotes, int maxNotes, double syncopation) {
        int notes[] = {-1};
        // The notes array holds the set of musical notes that
        // will be adjusted into the chord of the next measure.
        // 1 represents the root of the chord, 3 the third, 5
        // the fifth, and so on. -1 indicates no note. 
        
        int noteCount = 0;
        int fineness = 1; // 1=whole, 2=half, 4=quarter, 8=eight
        while (noteCount < minNotes || (noteCount < maxNotes && Math.random() > 0.5) ) {
            for (int ii=0; ii<notes.length; ii+= fineness) {
                if ((noteCount < maxNotes) & 
                        Math.random() > syncopation*syncopation) {//* (Math.log(fineness)/Math.log(2)+1) ) {
                    // This block is more likely with low syncopation
                    // or when generation is still in early stages.
                    
                    //Generate a note at this index
                    int choices[] = {1, 3, 5, 8};
                    notes[ii] = choices[randNum(0, choices.length-1)];
                    notes[ii] = randChoice(1,3,5,8);
                    if(ii != 0 & ii < notes.length - 1) {
                        if(notes[ii-1] != -1 & notes[ii+1] != -1) {
                            notes[ii] = randNum(Math.min(notes[ii-1],notes[ii+1])-1,
                                    Math.max(notes[ii-1],notes[ii+1])+1);
                        }
                    }
                    noteCount++;
                }
            }
            notes = doubleFineness(notes);
            noteCount = 0;
            for (int ii=0; ii<notes.length; ii++) if (notes[ii]>=0) noteCount++;
        }
        
        String rhythm = "";
        for (int ii=0; ii<notes.length; ii++) {
            if (notes[ii] == -1) rhythm += "-";
            else rhythm += Integer.toString(notes[ii]);
        }
        System.out.format(rhythm + " %.3f\n", calcSyncopation(rhythm));
        return rhythm + "|";
    }
    */
    double calcSyncopation(String rhythm) {
        int syncCount = 0, compareCount = 0;
            for (int syncLevel = 1; syncLevel<rhythm.length(); syncLevel*=2) {
                // Compare sixteenths, eights, quarters, halfs. Work up
                // from the smallest division. syncLevel is how many
                // characters apart to compare within each rhythm. 
                for (int down = 0; down+syncLevel < rhythm.length(); down+=(syncLevel*2)) {
                    // down is the index of the downbeat to compare. Add
                    // syncLevel to get the corresponding upbeat.
                    char downNote = rhythm.charAt(down);
                    char upNote = rhythm.charAt(down + syncLevel);
                    if (Character.isDigit(downNote) | Character.isDigit(upNote))
                        compareCount++;
                    if (!Character.isDigit(downNote) & Character.isDigit(upNote))
                        syncCount++;
                }
            }
            return 1.0 * syncCount / compareCount;
    }
    
    String randMeasurePreGen(int[] scale){
        String song; 
        int minNoteCount = 9999;
        int maxNoteCount = 0;
        String rhythms[] = {
            "12345-678---5-3-|", 
            "323-1135--3-2---|",
            "8-6-56--8-53-53-|",
            "3-5-32-1|",
            "11335432|",
            "13243532|",
            "3-3-3-45--4-3-1-|",
            "1-3-5---3---543-|",
            "5-43-451|",
            "--123-123-------|",
            "3-3-3-45--------|",
            "878--6-5|",
            "323-6-5------R--|",
            "1358|",
            "5--43---|",
            "5-----43--------|",
            "--43----|",
            "78--|",
            "1--5|",
            "321-|",
            "35|"
        };
        int notecount[] = new int[rhythms.length];
        // notecount is just the amount of notes in a measure.
        // Lower notecount means more sparseness in the phrase.
        double syncopation[] = new double[rhythms.length];
        // syncopation is the percent of offbeat notes without a
        // downbeat, e.g. a note on beat 4 without one on beat 3.
        for(int ii=0; ii<rhythms.length; ii++) {
            // For each of the rhythms...
            int rhythmLen = rhythms[ii].length();
            int noteCount = 0;
            for(int jj=0; jj<rhythmLen; jj++) {
                char c = rhythms[ii].charAt(jj);
                // For each character in the rhythm...
                if (Character.isDigit(c)) 
                    noteCount++;
            }
            if (noteCount > maxNoteCount) maxNoteCount = noteCount;
            if (noteCount < minNoteCount) minNoteCount = noteCount;
            notecount[ii] = noteCount;
            
            syncopation[ii] = calcSyncopation(rhythms[ii]);
        }
        // The min and max noteCount based on the sliders
        int sliderMin = (int)( minNoteCount + 
                jSlider3.getValue()/(100.0/(maxNoteCount - minNoteCount)));
        int sliderMax = (int)( minNoteCount + 
                jSlider3.getValue()/(100.0/(maxNoteCount - minNoteCount)));
        
        // Based on the number of candidate rhythms, pick one index to use.
        // If no candidates fit all parameters, choose at random.
        int potentialRhythms = 0;
        for (int ii=0; ii<rhythms.length; ii++)
            if (notecount[ii] >= sliderMin & notecount[ii] <= sliderMax) 
                potentialRhythms++;
        int randChoice = randNum(0, potentialRhythms-1);
        int rhythmIndex = randNum(0, rhythms.length-1);
        for (int ii=0; ii<rhythms.length; ii++)
            if (notecount[ii] >= sliderMin &
                    notecount[ii] <= sliderMax) {
                if (randChoice == 0) rhythmIndex = ii;
                randChoice--;
            }
        String chosenRhythm = rhythms[rhythmIndex];
        
        jTextArea1.setText(jTextArea1.getText() + chosenRhythm + "\n");
        song = "V0 ";
        song += quickNote(scale, chosenRhythm);
        return song;
    }
    
    char iToC(int ii) {
        return Character.forDigit(ii, 10); 
    }
    int cToI(char c) {
        return Character.getNumericValue(c);
    }
    
    String randMeasure(int[] scale) {
        double syncopation = jSlider5.getValue()/100.0;
        double eccentricity = jSlider7.getValue()/100.0;
        double density = jSlider4.getValue()/100.0;
        int granularity = jSlider3.getValue();
        char[] rhythm = new char[(int)(Math.pow(2, granularity-1))];
        
        
        // First create the actual beat: 0 is a note, - is blank
        for(int ii=0; ii<rhythm.length; ii++) rhythm[ii]='-';
        for(int ii=0; ii<rhythm.length-1; ii+=2) {
            // For each pair of notes, determine where to place notes
            if(Math.random() < density && Math.random() > syncopation)
                rhythm[ii] = '0';
            if(Math.random() < density && Math.random() < syncopation)
                rhythm[ii+1] = '0';
        } // At this point, rhythm looks like: 00--0-0- or 0-000-00
        System.out.println(new String(rhythm));
        for(int ii=0; ii<rhythm.length; ii++) 
            if (rhythm[ii]=='0') {
                rhythm[ii] = iToC(randChoice(1,3,5,8));
                break;
            }
        System.out.println(new String(rhythm));
        for(int ii=rhythm.length-1; ii>0; ii--) 
            if (rhythm[ii]=='0') {
                rhythm[ii] = iToC(randChoice(1,3,5,8));
                break;
            }
        System.out.println(new String(rhythm));
        for(int ii=0; ii<rhythm.length; ii++) 
            if (rhythm[ii]=='0' & Math.random() > eccentricity)
                rhythm[ii] = iToC(randChoice(1,3,5,8));
        System.out.println(new String(rhythm));
        for(int ii=0; ii<rhythm.length; ii++) 
            if (rhythm[ii]=='0') {
                int prev = 1;
                int next = 8;
                for(int jj=0; jj<ii; jj++) if(rhythm[jj] != '-') prev = cToI(rhythm[jj]);
                for(int jj=rhythm.length-1; jj>ii; jj--) if(rhythm[jj] != '-') next = cToI(rhythm[jj]);
                rhythm[ii] = iToC(randNum(prev,next));
            }
        System.out.println(new String(rhythm));
        //for(int ii=0; ii<rhythm.length; ii++)
        //    rhythm[ii] = iToC(randChoice(1,3,5,8));
        /*// Next, locate sets of at least 3 adjacent notes to create runs
        // like 123 121 321 323 343 345 865 565 878
        for(int ii=0; ii<rhythm.length - 3; ii++) {
            if(rhythm[ii]=='0' & rhythm[ii+1]=='0' & rhythm[ii+2]=='0') {
                int note1 = randChoice(1,3,5,8);
                int note2 = note1 + randChoice(-1,1);
                if (note2 == 9) note2 = 7;
                if (note2 == 0) note2 = 2;
                int note3 = note2 + randChoice(-1,1);
                if (note3 == 6) note3 = 5;
                if (note3 == 7) note3 = 8;
                rhythm[ii] = Character.forDigit(note1, 10); 
                rhythm[ii+1] = Character.forDigit(note2, 10); 
                rhythm[ii+2] = Character.forDigit(note3, 10); 
            }
        } // Repeat, but on a scale twice the previous length
        for(int ii=0; ii<rhythm.length - 5; ii++) {
            if(rhythm[ii]=='0' & rhythm[ii+2]=='0' & rhythm[ii+4]=='0') {
                int note1 = randChoice(1,3,5,8);
                int note2 = note1 + randChoice(-1,1);
                if (note2 == 9) note2 = 7;
                if (note2 == 0) note2 = 2;
                int note3 = note2 + randChoice(-1,1);
                if (note3 == 6) note3 = 5;
                if (note3 == 7) note3 = 8;
                rhythm[ii] = Character.forDigit(note1, 10); 
                rhythm[ii+2] = Character.forDigit(note2, 10); 
                rhythm[ii+4] = Character.forDigit(note3, 10); 
            }
        } // Then fill in the missing notes
        for(int ii=0; ii<rhythm.length; ii++) {
            if(rhythm[ii]=='0') rhythm[ii] = Character.forDigit(randChoice(1,3,5,8), 10); 
        }*/
        
        String melody = new String(rhythm);
                
        jTextArea1.setText(jTextArea1.getText() + melody + "\n");
        
        String song = "V0 ";
        song += quickNote(scale, melody+"|");
        return song;
    }
    
  /*  String randMeasure1(int[] scale){
        String song; 
        int minNoteCount = 1;
        int maxNoteCount = 8;
        // The min and max noteCount based on the sliders
        int sliderMin = (int)( minNoteCount + 
                jSlider2.getValue()/(100.0/(maxNoteCount - minNoteCount)));
        int sliderMax = (int)( minNoteCount + 
                jSlider3.getValue()/(100.0/(maxNoteCount - minNoteCount)));
        double syncopation = jSlider3.getValue()/100.0;
        
        System.out.println(Integer.toString(sliderMin) + "," +
                Integer.toString(sliderMax) + " ... " + syncopation);

        String chosenRhythm = randRhythm(sliderMin, sliderMax, 0.5);
        
        jTextArea1.setText(jTextArea1.getText() + chosenRhythm + "\n");
        song = "V0 ";
        song += quickNote(scale, chosenRhythm);
        return song;
    }*/
    
    int randChoice(int ... choices) {
        return choices[randNum(0,choices.length-1)];
    }
    
    String quickNote(int[] scale, String melody){
        String song = "";
        String lengthCounter = melody;
        int melodyLength = lengthCounter.replaceAll("[b#|]","").length();
        int measureCount = lengthCounter.replaceAll("[^|]","").length();
        double length = 0; 
        double duration = 1.0 * measureCount / melodyLength;
        int note = 0;
        for (int i = 0; i < melody.length(); i++){
            char c = melody.charAt(i);
            if(Character.isDigit(c) | c == 'R'){
                if (i != 0)
                    if (note >= 0)
                        song += " [" + (note) + "]/" + length;
                    else 
                        song += " R/" + String.valueOf(length);
                length = duration;
                if (c == 'R')
                    note = -1;
                else
                    note = scale[Character.getNumericValue(c)-1];
            }
            if(c == 'R')
                note = -1;
            if(c == 'b')
                note -= 1;
            if(c == '#')
                note += 1;
            if(c == '-')
                length += duration;
            if(c == '|')
                if (note >= 0)
                    song += " [" + (note) + "]/" + length;
                else 
                    song += " R/" + length;
        }
        String lower = " V1 [" + (scale[0]-12) + "]w+[" + (scale[2]-12)
                + "]w+[" + (scale[4]-12) + "]w ";
        song += lower;
        
        return song;
    }
    
    int randNum(int min, int max){
        if (max > min) {
            int tmp = max;
            max = min;
            min = tmp;
        }
        return (int)(min + Math.random() * (max-min + 1));
    }
    
    private class Music {
        private Player myPlayer = new Player();
        public Player getPlayer() {
            return this.myPlayer;
        }
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ProcMusic.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ProcMusic.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ProcMusic.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ProcMusic.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new ProcMusic().setVisible(true);
            }
        });
        
        
        

    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSlider jSlider1;
    private javax.swing.JSlider jSlider3;
    private javax.swing.JSlider jSlider4;
    private javax.swing.JSlider jSlider5;
    private javax.swing.JSlider jSlider6;
    private javax.swing.JSlider jSlider7;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}
